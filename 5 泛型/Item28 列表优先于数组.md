### Item28 列表优先于数组

> Arrays differ from generic types in two important ways. First, arrays are *covariant*. This scary-sounding word means simply that if Sub is a subtype of Super, then the array type Sub[] is a subtype of the array type Super[]. Generics, by contrast, are *invariant*: for any two distinct types Type1 and Type2, List<Type1> is neither a subtype nor a supertype of List<Type2> [JLS, 4.10; Naftalin07, 2.5]. You might think this means that generics are deficient, but arguably it is arrays that are deficient. This code fragment is legal:

数组和泛型主要有两个方面的不同。首先，数组是协变的（covariant）。这个听起来很可怕的词，意思却很简单：如果Sub是Super的子类型，那么其数组类型Sub[]也是数组类型Super[]的子类型。相反，泛型是非协变的：对于两个不同的类型Type1和Type2，List<Type1>永远都不会是List<Type2>的子类型或者父类型[JLS, 4.10; Naftalin07, 2.5]。你可能会因此觉得泛型好像有点缺陷，但是事实却证明，是数组有缺陷，下面的代码片段是合法的：

```java
// Fails at runtime!
Object[] objectArray = new Long[1];
objectArray[0] = "I don't fit in"; // Throws ArrayStoreException
```

> but this one is not:

但下面这个确是不合法的：

```java
// Won't compile!
List<Object> ol = new ArrayList<Long>(); // Incompatible types 
ol.add("I don't fit in");
```

> Either way you can’t put a String into a Long container, but with an array you find out that you’ve made a mistake at runtime; with a list, you find out at compile time. Of course, you’d rather find out at compile time.

不管是哪种方法，你都不能往Long容器中放String。但是使用数组的时候，你将在运行的时候发现错误；而使用列表的时候，你会在编译的时候发现。当然，还会在编译时发现更好。

> The second major difference between arrays and generics is that arrays are *reified* [JLS, 4.7]. This means that arrays know and enforce their element type at runtime. As noted earlier, if you try to put a String into an array of Long, you’ll get an ArrayStoreException. Generics, by contrast, are implemented by *erasure* [JLS, 4.6]. This means that they enforce their type constraints only at compile time and discard (or *erase*) their element type information at runtime. Erasure is what allowed generic types to interoperate freely with legacy code that didn’t use generics (Item 26), ensuring a smooth transition to generics in Java 5.

数组和泛型之间第二大主要的不同点在于，数组是具体化的（reified）[JLS, 4.7]。这意味着在运行时，数组是知道其元素类型的，并且会强制执行类型限制。正如前面写的那样，当你视图将一个String放到一个Long数组的时候，你就会获得一个ArrayStoreException。相反，泛型由于是通过类型擦除来实现的，这就意味着他们只能在编译期强制执行类型限制，而在运行时是丢弃（或者说“擦除”）其元素类型信息的。类型擦除是为了允许泛型代码可一个使用泛型之前的老代码进行互用（Item26）,以保证在Java5中平滑地过渡到泛型。

> Because of these fundamental differences, arrays and generics do not mix well. For example, it is illegal to create an array of a generic type, a parameterized type, or a type parameter. Therefore, none of these array creation expressions are legal: new List<E>[], new List<String>[], new E[]. All will result in *generic array creation* errors at compile time.

由于上面这些根本上的不同，所以，数组和泛型不能很好的混合使用。比如，创建泛型数组、参数化类型数组、类型参数数组都是不合法的。也就是说，下面这些创建表达式都是不合法的：new List<E>[]，new List<String>[]，new E[]。所有这些表达式在编译时都会产生泛型数组创建错误。

> Why is it illegal to create a generic array? Because it isn’t typesafe. If it were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a ClassCastException. This would violate the fundamental guarantee provided by the generic type system.

为什么使用泛型数组是不合法的？因为他是类型不安全的。如果这是合法的，编译器生成的转换，在其他方面都正常的程序中运行时，可能因为会抛出ClassCastException而失败。这就违反了泛型系统提供的基本保证了。

> To make this more concrete, consider the following code fragment:

为了更明确一些，看看下面这段代码：

```java
// Why generic array creation is illegal - won't compile! 
List<String>[] stringLists = new List<String>[1];           // (1)
List<Integer> intList = List.of(42);                        // (2)  
Object[] objects = stringLists;                             //（3）
objects[0] = intList;                                       //（4）
String s = stringLists[0].get(0);                           //（5）
```

Let’s pretend that line 1, which creates a generic array, is legal. Line 2 creates and initializes a List<Integer> containing a single element. Line 3 stores the List<String> array into an Object array variable, which is legal because arrays are covariant. Line 4 stores the List<Integer> into the sole element of the Object array, which succeeds because generics are implemented by erasure: the runtime type of a List<Integer> instance is simply List, and the runtime type of a List<String>[] instance is List[], so this assignment doesn’t generate an ArrayStoreException. Now we’re in trouble. We’ve stored a List<Integer> instance into an array that is declared to hold only List<String> instances. In line 5, we retrieve the sole element from the sole list in this array. The compiler automatically casts the retrieved element to String, but it’s an Integer, so we get a ClassCastException at runtime. In order to prevent this from happening, line 1 (which creates a generic array) must generate a compile-time error.

让我们假设在第1行中创建泛型数组是合法的。第2行中将创建并初始化一个包含单个元素的List<Integer>。在第3行中将List<String>数组保存到Object数组中，这个操作是合法的，因为数组是协变的。然后第4行把List<Integer>数组保存到Object数组的唯一元素中，这步操作可以成功，因为泛型是通过类型擦差来实现的：List<Integer>实例在运行时类型就是List，而List<String>[]实例在运行时类型就是List[]。因此这步操作不会生成ArrayStoreException。现在问题来了，我们已经往一个声明只能持有List<String>实例的数组中放了一个List<Integer>实例。在第5行中，我们将这个唯一的元素从数组的唯一的list中取出来的时候，编译器会自动将取出来的元素转化为String，但是这个元素确实Integer，所以在运行时会抛出ClassCastException。为了要阻止这个问题出现，在创建泛型数组的第一行在编译时，必须产生一条错误。

> Types such as E, List<E>, and List<String> are technically known as *non-reifiable* types [JLS, 4.7]. Intuitively speaking, a non-reifiable type is one whose runtime representation contains less information than its compile-time representation. Because of erasure, the only parameterized types that are reifiable are unbounded wildcard types such as List<?> and Map<?,?> (Item 26). It is legal, though rarely useful, to create arrays of unbounded wildcard types.
>
> The prohibition on generic array creation can be annoying. It means, for example, that it’s not generally possible for a generic collection to return an array of its element type (but see Item 33 for a partial solution). It also means that you get confusing warnings when using varargs methods (Item 53) in combination with generic types. This is because every time you invoke a varargs method, an array is created to hold the varargs parameters. If the element type of this array is not reifiable, you get a warning. The SafeVarargs annotation can be used to address this issue (Item 32).

从技术上讲， E, List<E>, 和 List<String>的类型被称为“不可具体化”类型。直观地说，一个不可具体化类型就在运行时的表示 包含的信息 少于其编译期的表示。由于类型擦除，唯一一个可具体化的参数类型是无限制通配符类型，比如List<?> 和 Map<?,?> (Item 26)。虽然创建无边界通配符类型的数组是合法的，但是很少使用。

禁止泛型数组的创建可能有点烦人。比如，这意味着，一般情况下，不可能为一个泛型集合返回一个其元素类型的数组（但在Item33中，有部分解决方案）。这也意味着，当你使用可变参数方法和泛型类型一起用的时候，会获得一个令人费解的警告。这是因为你每次调用一个可变参数方法的时候，会自动创建一个数组持有可变参数。如果这个数组的元素类型是不可具体化的时候，你就会获得这个警告。你可以使用SafeVarargs注解来解决这个问题（Item32）。

> When you get a generic array creation error or an unchecked cast warning on a cast to an array type, the best solution is often to use the collection type List<E> in preference to the array type E[]. You might sacrifice some conciseness or performance, but in exchange you get better type safety and interoperability.
>
> For example, suppose you want to write a Chooser class with a constructor that takes a collection, and a single method that returns an element of the collection chosen at random. Depending on what collection you pass to the constructor, you could use a chooser as a game die, a magic 8-ball, or a data source for a Monte Carlo simulation. Here’s a simplistic implementation without generics:

当你在转换到数组类型时遇到泛型数组创建错误或者非受检转换异常的时候，最好的方法是使用集合类型List<E>，而不是数组类型E[]。可能会牺牲一些性能，但是换回的却是更好的类型安全性和互用性。

比如，你现在想写一个Chooser类，该类有参数为一个集合的构造器，和一个方法，该方法返回这个集合中随机选择的一个元素。根据你传给构造器的集合而定，你可以使用chooser类做游戏骰子、魔术8球、或者是Monte Carlo 模拟的数据源。下面是不使用泛型的简单实现：

```java
// Chooser - a class badly in need of generics!
   public class Chooser {
       private final Object[] choiceArray;
       public Chooser(Collection choices) {
           choiceArray = choices.toArray();
			 }
       public Object choose() {
           Random rnd = ThreadLocalRandom.current();
           return choiceArray[rnd.nextInt(choiceArray.length)];
			 } 
  }
```

> To use this class, you have to cast the choose method’s return value from Object to the desired type every time you use invoke the method, and the cast will fail at runtime if you get the type wrong. Taking the advice of Item 29 to heart, we attempt to modify Chooser to make it generic. Changes are shown in boldface:

为了使用这个类，你必须要在每次调用choose方法的时候，把其返回值从Object类型转换为你想要的类型。并且，如果你把类型搞错了，在运行时，这个转换就会失败。把Item29的建议放在心里，我们努力将Chooser做成泛型的。下面的修改部分如粗体所示(在markdown的代码块里不会搞粗体）：

```java
// A first cut at making Chooser generic - won't compile 
public class Chooser<T> {
	private final T[] choiceArray;
	public Chooser(Collection<T> choices) { 
		choiceArray = choices.toArray();
	}
       // choose method unchanged
}
```

> If you try to compile this class, you’ll get this error message:

如果你编译这个类，你就会获得下面这条错误信息：

```java
Chooser.java:9: error: incompatible types: Object[] cannot be
   converted to T[]
           choiceArray = choices.toArray();
                                        ^
     where T is a type-variable:
       T extends Object declared in class Chooser
```

> No big deal, you say, I’ll cast the Object array to a T array:

你可能会说，问题不大。可以将这个Object数组转换为一个T数组：

```java
choiceArray = (T[]) choices.toArray();
```

> This gets rid of the error, but instead you get a warning:

这个方法可以解决这个error，但是你有会得到一个warning，如下：

```
Chooser.java:9: warning: [unchecked] unchecked cast
           choiceArray = (T[]) choices.toArray();
                                        ^
           required: T[], found: Object[]
					 where T is a type-variable:
T extends Object declared in class Chooser
```

> The compiler is telling you that it can’t vouch for the safety of the cast at runtime because the program won’t know what type T represents—remember, element type information is erased from generics at runtime. Will the program work? Yes, but the compiler can’t prove it. You could prove it to yourself, put the proof in a comment and suppress the warning with an annotation, but you’re better off eliminating the cause of warning (Item 27).

编译器告诉你：它不能确定在运行时的类型转换的安全性，因为程序不知道类型T代表的是什么——记住，泛型中的元素类型信息在运行时被擦除了。这个程序可以正常工作吗？可以的，但是这个编译器不能证明。你可以自己证明，然后在注解写明证据，并用注解来禁止这个警告。但是最好是消除造成这个警告的根源（Item27）。

> To eliminate the unchecked cast warning, use a list instead of an array. Here is a version of the Chooser class that compiles without error or warning:

为了消除这个非受检转换警告，使用list来代替数组。这是一个编译时既没有error也没有warning的Chooser类版本：

```java
// List-based Chooser - typesafe
public class Chooser<T> {
		private final List<T> choiceList;
		public Chooser(Collection<T> choices) { 
				choiceList = new ArrayList<>(choices);
		}
		public T choose() {
				Random rnd = ThreadLocalRandom.current();
				return choiceList.get(rnd.nextInt(choiceList.size()));
		} 
}
```

> This version is a tad more verbose, and perhaps a tad slower, but it’s worth it for the peace of mind that you won’t get a ClassCastException at runtime.
>
> In summary, arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant and erased. As a consequence, arrays provide runtime type safety but not compile-time type safety, and vice versa for generics. As a rule, arrays and generics don’t mix well. If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be to replace the arrays with lists.

这个版本可能有点啰嗦，也可能有点慢。但是这些是值得的，因为不会在运行的时候获得ClassCastException。

总结一下，数组和泛型有一些非常不同的类型规则，数组是协变和可具体化的；而泛型是非协变和擦除的。因此，数组可以提供运行时类型安全但是没有贬义是类型安全，而泛型却恰恰相反。一般来说，数组和泛型不能混用。如果你发现你自己混用了他们，并且出现了编译error或者warning。你的第一反应应该是用列表替换数组。





